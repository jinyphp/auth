# JinyAuth 인증 방식

JinyAuth 패키지의 사용자 인증 시스템은 **샤딩(Sharding)**과 **JWT(JSON Web Token)** 기반으로 구현되어 있습니다.

## 목차

1. [개요](#개요)
2. [샤딩 시스템](#샤딩-시스템)
3. [JWT 인증](#jwt-인증)
4. [인증 흐름](#인증-흐름)
5. [설정 방법](#설정-방법)
6. [사용 예제](#사용-예제)
7. [문제 해결](#문제-해결)

---

## 개요

### 주요 특징

- **샤딩 기반 데이터 분산**: 사용자 데이터를 여러 테이블(`user_000`, `user_001`, ...)로 분산 저장
- **JWT 토큰 인증**: Stateless 인증으로 확장성 향상
- **UUID 기반 샤드 키**: 고유 식별자로 샤드 결정
- **인덱스 테이블**: 빠른 사용자 조회를 위한 인덱스 관리

### 아키텍처

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │ Login Request
       ▼
┌─────────────────────┐
│  Auth Controller    │
│  - Validate         │
│  - Find Shard       │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────┐     ┌──────────────┐
│  Shard Manager      │────▶│ users_index  │ (인덱스 테이블)
│  - Hash UUID        │     └──────────────┘
│  - Route to Shard   │
└──────┬──────────────┘
       │
       ▼
┌─────────────────────────────────────┐
│         Sharded Tables              │
│  ┌──────────┐  ┌──────────┐        │
│  │ user_000 │  │ user_001 │  ...   │
│  └──────────┘  └──────────┘        │
└─────────────────────────────────────┘
       │
       ▼
┌─────────────────────┐
│   JWT Generator     │
│  - Create Token     │
│  - Sign with Secret │
└──────┬──────────────┘
       │
       ▼
┌─────────────┐
│   Client    │
│ (JWT Token) │
└─────────────┘
```

---

## 샤딩 시스템

### 샤딩이란?

샤딩(Sharding)은 대용량 데이터를 여러 데이터베이스 테이블로 분산 저장하는 기법입니다. JinyAuth는 사용자 데이터를 `user_0xx` 형태의 여러 테이블로 분산하여 성능과 확장성을 향상시킵니다.

### 샤딩 설정

`jiny/auth/config/setting.json`에서 샤딩 설정을 관리합니다:

```json
{
    "sharding": {
        "enable": true,
        "shard_count": 2,
        "shard_key": "uuid",
        "strategy": "hash",
        "use_uuid": true,
        "uuid_version": 4,
        "use_index_tables": true
    }
}
```

#### 설정 항목 설명

| 항목 | 설명 | 기본값 |
|------|------|--------|
| `enable` | 샤딩 활성화 여부 | `true` |
| `shard_count` | 샤드 테이블 개수 | `2` |
| `shard_key` | 샤드 결정 키 | `"uuid"` |
| `strategy` | 샤딩 전략 | `"hash"` |
| `use_uuid` | UUID 사용 여부 | `true` |
| `uuid_version` | UUID 버전 | `4` |
| `use_index_tables` | 인덱스 테이블 사용 | `true` |

### 샤드 테이블 구조

사용자 데이터는 다음과 같이 분산 저장됩니다:

```
users_index          (인덱스 테이블)
├── id
├── uuid             (고유 식별자)
├── email
├── shard_id         (샤드 번호: 0, 1, 2, ...)
└── created_at

user_000             (샤드 0)
├── id
├── uuid
├── name
├── email
├── password
└── ...

user_001             (샤드 1)
├── id
├── uuid
├── name
├── email
├── password
└── ...
```

### 샤딩 전략

#### Hash 전략

UUID를 해시하여 샤드를 결정합니다:

```php
$shardId = hash('crc32', $uuid) % $shardCount;
```

**예시**:
- UUID: `550e8400-e29b-41d4-a716-446655440000`
- Shard Count: `2`
- Hash: `crc32(uuid) = 1234567890`
- Shard ID: `1234567890 % 2 = 0` → `user_000`

### 인덱스 테이블

빠른 사용자 조회를 위해 `users_index` 테이블을 사용합니다:

```sql
CREATE TABLE users_index (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    uuid VARCHAR(36) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    shard_id TINYINT UNSIGNED NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_uuid (uuid),
    INDEX idx_email (email)
);
```

**조회 흐름**:
1. 이메일로 `users_index`에서 `shard_id` 조회
2. 해당 `user_0xx` 테이블에서 사용자 정보 조회

---

## JWT 인증

### JWT란?

JWT(JSON Web Token)는 클라이언트와 서버 간 정보를 안전하게 전송하기 위한 토큰 기반 인증 방식입니다.

### JWT 설정

```json
{
    "method": "jwt",
    "jwt": {
        "secret": "",
        "access_token_expiry": 3600,
        "refresh_token_expiry": 2592000,
        "algorithm": "HS256"
    }
}
```

#### 설정 항목 설명

| 항목 | 설명 | 기본값 |
|------|------|--------|
| `secret` | JWT 서명 비밀 키 | (환경변수에서 로드) |
| `access_token_expiry` | 액세스 토큰 만료 시간 (초) | `3600` (1시간) |
| `refresh_token_expiry` | 리프레시 토큰 만료 시간 (초) | `2592000` (30일) |
| `algorithm` | 서명 알고리즘 | `"HS256"` |

### JWT 구조

JWT는 세 부분으로 구성됩니다:

```
Header.Payload.Signature
```

**예시**:
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiI1NTBlODQwMC1lMjliLTQxZDQtYTcxNi00NDY2NTU0NDAwMDAiLCJleHAiOjE3MDAwMDAwMDB9.
SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

#### Header (헤더)

```json
{
    "alg": "HS256",
    "typ": "JWT"
}
```

#### Payload (페이로드)

```json
{
    "sub": "550e8400-e29b-41d4-a716-446655440000",  // UUID
    "email": "user@example.com",
    "shard_id": 0,
    "exp": 1700000000,  // 만료 시간
    "iat": 1699996400   // 발급 시간
}
```

#### Signature (서명)

```
HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    secret
)
```

---

## 인증 흐름

### 1. 회원가입 흐름

```
┌────────┐
│ Client │
└───┬────┘
    │ POST /register
    │ { name, email, password }
    ▼
┌─────────────────┐
│ RegisterController
│ 1. Validate      │
│ 2. Generate UUID │
└───┬─────────────┘
    │
    ▼
┌─────────────────┐
│ Shard Manager   │
│ 1. Hash UUID    │
│ 2. shard_id = 0 │
└───┬─────────────┘
    │
    ▼
┌─────────────────────────┐
│ Database                │
│ 1. Insert users_index   │
│ 2. Insert user_000      │
└───┬─────────────────────┘
    │
    ▼
┌────────┐
│ Client │
│ Success│
└────────┘
```

### 2. 로그인 흐름

```
┌────────┐
│ Client │
└───┬────┘
    │ POST /login
    │ { email, password }
    ▼
┌─────────────────────┐
│ LoginController     │
│ 1. Find in index    │
│ 2. Get shard_id     │
└───┬─────────────────┘
    │
    ▼
┌─────────────────────┐
│ user_000            │
│ 1. Verify password  │
│ 2. Load user data   │
└───┬─────────────────┘
    │
    ▼
┌─────────────────────┐
│ JWT Generator       │
│ 1. Create payload   │
│ 2. Sign token       │
└───┬─────────────────┘
    │
    ▼
┌────────────────────┐
│ Client             │
│ { access_token,    │
│   refresh_token }  │
└────────────────────┘
```

### 3. 인증된 요청 흐름

```
┌────────┐
│ Client │
└───┬────┘
    │ GET /api/profile
    │ Authorization: Bearer <token>
    ▼
┌─────────────────────┐
│ JWT Middleware      │
│ 1. Verify signature │
│ 2. Check expiry     │
│ 3. Extract payload  │
└───┬─────────────────┘
    │
    ▼
┌─────────────────────┐
│ Shard Manager       │
│ 1. Get shard_id     │
│ 2. Route to shard   │
└───┬─────────────────┘
    │
    ▼
┌─────────────────────┐
│ user_000            │
│ Load user data      │
└───┬─────────────────┘
    │
    ▼
┌────────┐
│ Client │
│ { user }│
└────────┘
```

---

## 설정 방법

### 1. 환경 변수 설정

`.env` 파일에 JWT 시크릿 키를 설정합니다:

```env
JWT_SECRET=your-256-bit-secret-key-here
```

### 2. 샤딩 설정

`jiny/auth/config/setting.json`에서 샤드 개수를 조정합니다:

```json
{
    "sharding": {
        "enable": true,
        "shard_count": 4,  // 4개의 샤드 테이블
        "shard_key": "uuid",
        "strategy": "hash"
    }
}
```

### 3. 마이그레이션 실행

샤드 테이블을 생성합니다:

```bash
php artisan migrate
```

자동으로 다음 테이블이 생성됩니다:
- `users_index`
- `user_000`
- `user_001`
- `user_002`
- `user_003`

---

## 사용 예제

### 사용자 조회

#### auth() 헬퍼 사용

```php
// 현재 인증된 사용자 조회 (자동으로 샤드 라우팅)
$user = auth()->user();

echo $user->name;
echo $user->email;
echo $user->uuid;
```

#### 수동 샤드 조회

```php
use Jiny\Auth\Services\ShardManager;

$shardManager = app(ShardManager::class);

// 이메일로 샤드 찾기
$shardId = $shardManager->findShardByEmail('user@example.com');

// 해당 샤드에서 사용자 조회
$user = DB::table("user_{$shardId}")
    ->where('email', 'user@example.com')
    ->first();
```

### JWT 토큰 생성

```php
use Jiny\Auth\Services\JwtService;

$jwtService = app(JwtService::class);

$payload = [
    'sub' => $user->uuid,
    'email' => $user->email,
    'shard_id' => $user->shard_id,
];

$accessToken = $jwtService->createAccessToken($payload);
$refreshToken = $jwtService->createRefreshToken($payload);

return response()->json([
    'access_token' => $accessToken,
    'refresh_token' => $refreshToken,
    'expires_in' => 3600,
]);
```

### JWT 토큰 검증

```php
use Jiny\Auth\Services\JwtService;

$jwtService = app(JwtService::class);

try {
    $token = request()->bearerToken();
    $payload = $jwtService->verify($token);
    
    // 페이로드에서 사용자 정보 추출
    $uuid = $payload['sub'];
    $shardId = $payload['shard_id'];
    
    // 사용자 조회
    $user = DB::table("user_{$shardId}")
        ->where('uuid', $uuid)
        ->first();
        
} catch (\Exception $e) {
    return response()->json(['error' => 'Invalid token'], 401);
}
```

### 토큰 갱신

```php
use Jiny\Auth\Services\JwtService;

$jwtService = app(JwtService::class);

try {
    $refreshToken = request()->input('refresh_token');
    $payload = $jwtService->verify($refreshToken);
    
    // 새 액세스 토큰 발급
    $newAccessToken = $jwtService->createAccessToken($payload);
    
    return response()->json([
        'access_token' => $newAccessToken,
        'expires_in' => 3600,
    ]);
    
} catch (\Exception $e) {
    return response()->json(['error' => 'Invalid refresh token'], 401);
}
```

---

## 문제 해결

### 샤드를 찾을 수 없음

**증상**: `Shard not found for user` 에러

**원인**:
- `users_index` 테이블에 사용자 정보 없음
- 샤드 ID가 잘못됨

**해결**:
```php
// 인덱스 테이블 확인
$index = DB::table('users_index')
    ->where('email', 'user@example.com')
    ->first();

if (!$index) {
    // 인덱스 재생성
    $user = DB::table('users')->where('email', 'user@example.com')->first();
    DB::table('users_index')->insert([
        'uuid' => $user->uuid,
        'email' => $user->email,
        'shard_id' => hash('crc32', $user->uuid) % config('auth.sharding.shard_count'),
    ]);
}
```

### JWT 토큰 검증 실패

**증상**: `Token signature verification failed`

**원인**:
- JWT 시크릿 키 불일치
- 토큰 만료

**해결**:
```bash
# .env 파일에서 JWT_SECRET 확인
grep JWT_SECRET .env

# 설정 캐시 클리어
php artisan config:clear
```

### 샤드 간 데이터 불일치

**증상**: 사용자 데이터가 여러 샤드에 중복 저장됨

**원인**:
- UUID 생성 로직 오류
- 샤드 라우팅 로직 오류

**해결**:
```php
// 중복 데이터 확인
for ($i = 0; $i < config('auth.sharding.shard_count'); $i++) {
    $count = DB::table("user_{$i}")
        ->where('email', 'user@example.com')
        ->count();
    echo "Shard {$i}: {$count} records\n";
}

// 올바른 샤드로 마이그레이션
// (수동 작업 필요)
```

---

## 보안 고려사항

### JWT 시크릿 키 관리

- **강력한 키 사용**: 최소 256비트 이상
- **환경 변수 사용**: 코드에 하드코딩 금지
- **정기적 갱신**: 보안 정책에 따라 주기적으로 변경

```bash
# 강력한 시크릿 키 생성
php artisan key:generate --show
```

### 토큰 만료 시간

- **액세스 토큰**: 짧게 설정 (1시간 권장)
- **리프레시 토큰**: 길게 설정 (30일 권장)

### HTTPS 사용

JWT 토큰은 반드시 HTTPS를 통해 전송해야 합니다:

```nginx
# Nginx 설정
server {
    listen 443 ssl;
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
}
```

---

## 성능 최적화

### 인덱스 최적화

```sql
-- users_index 테이블 인덱스
CREATE INDEX idx_uuid ON users_index(uuid);
CREATE INDEX idx_email ON users_index(email);

-- 샤드 테이블 인덱스
CREATE INDEX idx_uuid ON user_000(uuid);
CREATE INDEX idx_email ON user_000(email);
```

### 캐싱

```php
use Illuminate\Support\Facades\Cache;

// 사용자 정보 캐싱
$user = Cache::remember("user:{$uuid}", 3600, function () use ($uuid, $shardId) {
    return DB::table("user_{$shardId}")
        ->where('uuid', $uuid)
        ->first();
});
```

### 샤드 개수 선택

- **소규모** (< 10만 사용자): 2-4 샤드
- **중규모** (10만-100만): 8-16 샤드
- **대규모** (> 100만): 32+ 샤드

---

## 참고 자료

- [JWT 공식 문서](https://jwt.io/)
- [Database Sharding 개념](https://en.wikipedia.org/wiki/Shard_(database_architecture))
- [Laravel Authentication](https://laravel.com/docs/authentication)
- [UUID RFC 4122](https://tools.ietf.org/html/rfc4122)

---

## 버전 히스토리

### v1.0.0
- 샤딩 시스템 구현
- JWT 인증 구현
- UUID 기반 샤드 키
- 인덱스 테이블 지원
